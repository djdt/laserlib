import numpy as np

from .calc import get_weights, weighted_linreg

from typing import Union


class Calibration(object):
    def __init__(
        self,
        intercept: float = 0.0,
        gradient: float = 1.0,
        rsq: float = None,
        points: np.ndarray = None,
        weights: Union[np.ndarray, str] = None,
        weighting: str = "None",
        unit: str = "",
    ):
        """Weights can be automatically generated by passing x, 1/x, or 1/(x^2) to weights."""

        self.intercept = intercept
        self.gradient = gradient
        self.unit = unit

        self.rsq = rsq
        self._points = None
        if points is not None:
            self.points = points

        self._weights = None
        if weights is not None:
            self.weights = weights
        self.weighting = weighting

    @property
    def points(self) -> np.ndarray:
        return self._points

    @points.setter
    def points(self, points: np.ndarray) -> None:
        points = np.array(points, dtype=float)
        if points.ndim != 2:
            raise ValueError("Points must have 2 dimensions.")
        if points.shape[0] < 2 or points.shape[1] != 2:
            raise ValueError("A minimum of 2 points required.")
        self._points = points

    @property
    def weights(self) -> np.ndarray:
        return self._weights

    @weights.setter
    def weights(self, weights: Union[np.ndarray, str]) -> None:
        if self._points is None:
            self._weights = None
        elif isinstance(weights, str):
            self._weights = get_weights(self._points[:, 0], weights)
        else:
            weights = np.array(weights, dtype=float)
            if weights.ndim != 1 or weights.size != self.points[:, 0].size:
                raise ValueError("Weights must have same length as points.")
            self._weights = weights

    def __str__(self) -> str:
        s = f"y = {self.gradient:.4g} · x - {self.intercept:.4g}"
        if self.rsq is not None:
            s += f"\nr² = {self.rsq:.4f}"
        return s

    def concentrations(self) -> np.ndarray:
        if self.points is None:
            return np.array([], dtype=np.float64)
        return self.points[:, 0]

    def counts(self) -> np.ndarray:
        if self.points is None:
            return np.array([], dtype=np.float64)
        return self.points[:, 1]

    def update_linreg(self) -> None:
        if self.points is None:
            self.gradient, self.intercept, self.rsq = 1.0, 0.0, None
        else:
            no_nans = ~np.isnan(self.points).any(axis=1)
            if no_nans.size == 0:
                self.gradient, self.intercept, self.rsq = 1.0, 0.0, None
            else:
                x, y = self.points[no_nans, 0], self.points[no_nans, 1]
                w = self._weights
                if w is not None:
                    w = w[no_nans]
                self.gradient, self.intercept, self.rsq = weighted_linreg(x, y, w)

    def calibrate(self, data: np.ndarray) -> np.ndarray:
        if self.intercept == 0.0 and self.gradient == 1.0:
            return data
        return (data - self.intercept) / self.gradient

    @classmethod
    def from_points(
        cls,
        points: np.ndarray,
        weights: Union[np.ndarray, str] = None,
        weighting: str = "None",
        unit: str = "",
    ):
        calibration = cls(
            points=points, weights=weights, weighting=weighting, unit=unit
        )
        calibration.update_linreg()
        return calibration
