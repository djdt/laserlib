import numpy as np

# from .. import __version__
from .error import LaserLibException

# from .. import Laser, LaserConfig, LaserCalibration
# from typing import Tuple


def load(path: str, isotope: str = "Unknown") -> np.ndarray:
    with open(path, "rb") as fp:
        try:
            cleaned = (line.replace(b";", b",").replace(b"\t", b",") for line in fp)
            data = np.genfromtxt(
                cleaned, delimiter=",", dtype=(isotope, np.float64), comments="#"
            )
        except ValueError as e:
            raise LaserLibException("Could not parse file.") from e

        if data.ndim != 2:
            raise LaserLibException(f"Invalid data dimensions '{data.ndim}'.")

    return data


# def load_pewpew(
#     path: str,
#     isotope: str = "Unknown",
#     config: LaserConfig = None,
#     read_config: bool = True,
#     read_calibration: bool = True,
# ) -> Laser:
#     """Imports the given CSV file, returning a LaserData object.

#     Each row of the CSV is read as a line of laser data.
#     An optional # commented header (see exportCsv) containing
#     configuration data may also be read.

#     Args:
#         path: Path to the CSV file
#         isotope: Name of the isotope
#         config: Laser configuration to apply
#         read_config: If True, attempts to read config from header data
#         read_calibration: If True, attempts to read calibration from header data

#     Returns:
#         The LaserData object.

#     Raises:
#         PewPewFileError: Malformed file.
#         PewPewConfigError: Invalid config.
#         PewPewDataError: Invalild data.

#     """
#     calibration = LaserCalibration()

#     with open(path, "rb") as fp:
#         line = fp.readline().lstrip(b"#").strip()
#         if line.startswith(b"Pew Pew "):  # CSV generated by pewpew
#             # Version
#             version = line[8:]
#             if version < b"0.1.0":
#                 raise LaserLibException(f"Unsupported CSV version '{version}'.")
#             # Isotope
#             line = fp.readline().lstrip(b"#").strip()
#             if b"=" not in line:
#                 raise LaserLibException(f"Malformed isotope line '{line}'.")
#             tokens = line.split(b"=")
#             if tokens[0] != b"isotope":
#                 raise LaserLibException(f"Malformed isotope line '{line}'.")
#             isotope = tokens[1].decode()
#             # Config
#             if read_config or read_calibration:
#                 line = fp.readline().lstrip(b"#").strip()
#                 if read_config:
#                     if config is None:
#                         config = LaserConfig()
#                     try:
#                         tokens = line.split(b";")
#                         for token in tokens:
#                             k, v = token.split(b"=")
#                             setattr(config, k.decode(), float(v))
#                     except (KeyError, ValueError):
#                         raise LaserLibException(f"Malformed config line '{line}'.")
#             # Calibration
#             if read_calibration:
#                 line = fp.readline().lstrip(b"#").strip()
#                 try:
#                     tokens = line.split(b";")
#                     for token in tokens:
#                         k, v = token.split(b"=")
#                         if k == b"intercept":
#                             calibration.intercept = float(v)
#                         elif k == b"gradient":
#                             calibration.gradient = float(v)
#                         elif k == b"unit":
#                             calibration.unit = v.decode()
#                         else:
#                             raise KeyError(k)
#                 except (KeyError, ValueError):
#                     raise LaserLibException(f"Malformed calibration line '{line}'")

#     laser = Laser(
#         config=config, name=os.path.splitext(os.path.basename(path))[0], filepath=path
#     )
#     # Only put calibration in if requested
#     if read_calibration:
#         laser.data[isotope] = LaserData(
#             data, isotope, intercept=intercept, gradient=gradient, unit=unit
#         )
#     else:
#         laser.calibration[isotope] = LaserData(data, isotope)

#     return laser

def save(path: str, data: np.ndarray) -> None:
    np.savetxt(path, data, fmt="%g", delimiter=",")


# def save(
#     path: str,
#     laser: Laser,
#     isotope: str,
#     calibrate: bool = False,
#     extent: Tuple[float, float, float, float] = None,
#     include_header: bool = False,
# ) -> None:
#     header = ""
#     if include_header:
#         config = laser.config
#         # calibration = laser.calibration
#         header = (
#             f"Pew Pew {__version__}\nisotope={isotope}\n"
#             f"spotsize={config.spotsize};speed={config.speed};"
#             f"scantime={config.scantime}\n"
#             f"intercept={laser.calibration[isotope].intercept};"
#             f"gradient={laser.calibration[isotope].gradient};"
#             f"unit={laser.calibration[isotope].unit}\n"
#         )
#     np.savetxt(
#         path,
#         laser.get(isotope, calibrate=calibrate, extent=extent),
#         fmt="%g",
#         delimiter=",",
#         header=header,
#     )
